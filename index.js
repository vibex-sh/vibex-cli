import readline from 'readline';
import { program, Command } from 'commander';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import { fileURLToPath } from 'url';
import crypto from 'crypto';
import chalk from 'chalk';
import cliProgress from 'cli-progress';

// Constants
const POLL_INTERVAL_MS = 1000;
const MAX_POLL_ATTEMPTS = 60;
const DEFAULT_WORKER_URL = 'https://ingest.vibex.sh';
const DEFAULT_WEB_URL = 'https://vibex.sh';
const PIPED_INPUT_DELAY_MS = parseInt(process.env.VIBEX_PIPE_DELAY_MS || '300', 10);

// Get version from package.json
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJsonPath = join(__dirname, 'package.json');
let cliVersion = '0.0.0';
try {
  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
  cliVersion = packageJson.version || '0.0.0';
} catch (error) {
  // Fallback if package.json can't be read - try to read from parent directory
  try {
    const parentPackageJsonPath = join(__dirname, '..', 'package.json');
    const packageJson = JSON.parse(readFileSync(parentPackageJsonPath, 'utf8'));
    cliVersion = packageJson.version || '0.0.0';
  } catch (e) {
    // If both fail, use default
  }
}

// Session ID generation is now handled by the server
// This function is kept for backward compatibility but should not be used for new sessions
function generateSessionId() {
  // DEPRECATED: Session IDs should be generated by the server
  // This is only used as a fallback if server creation fails
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let result = 'vibex-';
  
  // Use crypto.randomBytes for cryptographically secure random generation
  const randomBytes = crypto.randomBytes(12);
  for (let i = 0; i < 12; i++) {
    result += chars[randomBytes[i] % chars.length];
  }
  
  return result;
}

function normalizeSessionId(sessionId) {
  if (!sessionId) return null;
  // If it doesn't start with 'vibex-', add it
  if (!sessionId.startsWith('vibex-')) {
    return `vibex-${sessionId}`;
  }
  return sessionId;
}

/**
 * Phase 1.8: Log Normalization for CLI
 * Intelligently transforms log data into hybrid JSON structure
 */

function normalizeLevel(level) {
  if (!level) return 'debug';
  const levelStr = String(level).toLowerCase();
  if (['debug', 'dbg', 'trace'].includes(levelStr)) return 'debug';
  if (['info', 'information', 'log'].includes(levelStr)) return 'info';
  if (['warn', 'warning', 'wrn'].includes(levelStr)) return 'warn';
  if (['error', 'err', 'exception', 'fatal', 'critical'].includes(levelStr)) return 'error';
  return 'debug';
}

function extractMetrics(payload) {
  const metrics = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return metrics;
  }
  if (payload.metrics && typeof payload.metrics === 'object' && !Array.isArray(payload.metrics)) {
    for (const [key, value] of Object.entries(payload.metrics)) {
      if (typeof value === 'number') {
        metrics[key] = value;
      }
    }
    return metrics;
  }
  const knownContextFields = new Set([
    'trace_id', 'traceId', 'user_id', 'userId', 'request_id', 'requestId',
    'correlation_id', 'correlationId', 'span_id', 'spanId', 'session_id', 'sessionId',
    'id', 'pid', 'port', 'year', 'timestamp', 'time', 'date', 'createdAt', 'updatedAt',
    'datetime', 'ts', 'utc', 'iso', 'exc_info', 'exception', 'error', 'message', 'msg', 'level', 'severity', 'log_level'
  ]);
  for (const [key, value] of Object.entries(payload)) {
    const keyLower = key.toLowerCase();
    if (knownContextFields.has(keyLower)) continue;
    if (keyLower.includes('timestamp') || keyLower.includes('time') || keyLower.includes('date')) continue;
    if (typeof value === 'number') {
      if (key.endsWith('_ms') || key.endsWith('_count') || key.endsWith('_size') ||
          key.endsWith('Ms') || key.endsWith('Count') || key.endsWith('Size') ||
          ['cpu', 'memory', 'latency', 'response_time', 'duration'].some(pattern => keyLower.includes(pattern))) {
        metrics[key] = value;
      }
    }
  }
  return metrics;
}

function extractContext(payload) {
  const context = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return context;
  }
  if (payload.context && typeof payload.context === 'object' && !Array.isArray(payload.context)) {
    return payload.context;
  }
  const knownContextFields = {
    'trace_id': 'trace_id', 'traceId': 'trace_id',
    'user_id': 'user_id', 'userId': 'user_id',
    'request_id': 'request_id', 'requestId': 'request_id',
    'correlation_id': 'correlation_id', 'correlationId': 'correlation_id',
    'span_id': 'span_id', 'spanId': 'span_id',
    'session_id': 'session_id', 'sessionId': 'session_id',
  };
  for (const [field, normalizedKey] of Object.entries(knownContextFields)) {
    if (payload[field] !== undefined) {
      context[normalizedKey] = payload[field];
    }
  }
  return context;
}

function normalizeToHybrid(message, level, payload) {
  const merged = { ...(payload || {}) };
  let normalizedMessage = message;
  if (!normalizedMessage && merged.message) normalizedMessage = merged.message;
  if (!normalizedMessage && merged.msg) normalizedMessage = merged.msg;
  const normalizedLevel = normalizeLevel(level || merged.level || merged.severity || merged.log_level);
  const metrics = extractMetrics(merged);
  const context = extractContext(merged);
  const annotation = merged._annotation;
  const hybrid = {
    message: normalizedMessage, // Can be null/undefined
    level: normalizedLevel,
    metrics: metrics,
    context: context,
  };
  if (annotation) hybrid._annotation = annotation;
  for (const [key, value] of Object.entries(merged)) {
    if (!['message', 'msg', 'level', 'severity', 'log_level', 'metrics', 'context', '_annotation'].includes(key)) {
      if (!(key in hybrid)) hybrid[key] = value;
    }
  }
  return hybrid;
}

/**
 * Get production URLs
 * CLI only supports production server
 */
function getProductionUrls() {
  return {
    webUrl: process.env.VIBEX_WEB_URL || DEFAULT_WEB_URL,
  };
}

function getConfigPath() {
  // Check for custom config path from environment variable
  if (process.env.VIBEX_CONFIG_PATH) {
    return process.env.VIBEX_CONFIG_PATH;
  }
  // Default: ~/.vibex/config.json
  const configDir = join(homedir(), '.vibex');
  return join(configDir, 'config.json');
}

async function getStoredToken() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      const config = JSON.parse(await readFile(configPath, 'utf-8'));
      return config.token || null;
    }
  } catch (error) {
    // Ignore errors (file doesn't exist or invalid JSON)
  }
  return null;
}

function getStoredConfig() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
  } catch (error) {
    // Ignore errors
  }
  return null;
}

async function storeToken(token) {
  try {
    const configPath = getConfigPath();
    const configDir = join(homedir(), '.vibex');
    if (!existsSync(configDir)) {
      await mkdir(configDir, { recursive: true });
    }
    
    const config = {
      token,
      updatedAt: new Date().toISOString(),
    };
    
    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');
    return true;
  } catch (error) {
    console.error('Failed to store token:', error.message);
    return false;
  }
}

async function handleLogin() {
  const configPath = getConfigPath();
  const existingConfig = getStoredConfig();
  const { webUrl } = getProductionUrls();
  
  console.log('\n  üîê vibex.sh CLI Authentication\n');
  console.log(`  üìÅ Config location: ${configPath}`);
  
  if (existingConfig?.token) {
    console.log(`  ‚ö†Ô∏è  You already have a token stored. This will replace it.\n`);
  }
  
  // Generate unique state (nonce) for OAuth flow
  const state = crypto.randomBytes(16).toString('hex');
  const authUrl = `${webUrl}/api/cli-auth?state=${state}`;
  
  console.log('  Opening browser for authentication...\n');
  console.log(`  If browser doesn't open, visit: ${authUrl}\n`);
  
  // Open browser
  const platform = process.platform;
  let command;
  if (platform === 'darwin') {
    command = 'open';
  } else if (platform === 'win32') {
    command = 'start';
  } else {
    command = 'xdg-open';
  }
  
  spawn(command, [authUrl], { detached: true, stdio: 'ignore' });
  
  // Poll for token
  console.log('  Waiting for authentication...');
  let attempts = 0;
  
  while (attempts < MAX_POLL_ATTEMPTS) {
    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
    attempts++;
    
    try {
      const response = await httpRequest(`${webUrl}/api/cli-auth?state=${state}`, {
        method: 'GET',
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          await storeToken(data.token);
          const configPath = getConfigPath();
          console.log('\n  ‚úÖ Authentication successful!');
          console.log(`  üìÅ Token saved to: ${configPath}`);
          console.log(`  üí° This token will be used automatically for future commands.\n`);
          return data.token;
        }
      }
    } catch (error) {
      // Continue polling
    }
  }
  
  console.log('\n  ‚è±Ô∏è  Authentication timeout. Please try again.\n');
  process.exit(1);
}

function httpRequest(url, options) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === 'https:';
    const httpModule = isHttps ? https : http;
    
    const req = httpModule.request(url, options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve(parsed) });
        } catch (e) {
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve({}) });
        }
      });
    });
    
    req.on('error', reject);
    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}

// claimSession function removed - session claiming is no longer supported
// All sessions must be created with authentication

// Removed getSessionAuthCode - auth codes should only come from:
// 1. claim-session-with-token response (for claimed sessions)
// 2. socket.io session-auth-code event (for unclaimed sessions)
// Never fetch auth codes via public API endpoint - security vulnerability 

function printBanner(sessionId, authCode = null) {
  const { webUrl } = getProductionUrls();
  const dashboardUrl = authCode 
    ? `${webUrl}/${sessionId}?auth=${authCode}`
    : `${webUrl}/${sessionId}`;
  
  console.log('\n');
  console.log(chalk.cyan('  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'));
  console.log(chalk.cyan('  ‚ïë         üîç vibex.sh is watching...    ‚ïë'));
  console.log(chalk.cyan('  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'));
  console.log('\n');
  console.log(chalk.white(`  Session ID: ${chalk.bold(sessionId)}`));
  if (authCode) {
    console.log(chalk.white(`  Auth Code:  ${chalk.bold(authCode)}`));
  }
  console.log(chalk.white(`  Dashboard:  ${chalk.underline.cyan(dashboardUrl)}`));
  console.log('\n');
}

/**
 * Handle init command - create a new session with parser selection
 */
async function handleInit(options) {
  const { webUrl } = getProductionUrls();
  
  // Interactive prompt for parser selection
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  const question = (query) => new Promise((resolve) => rl.question(query, resolve));
  
  try {
    console.log('\n  üîß vibex.sh Session Initialization\n');
    
    // Fetch available parsers from public API
    let availableParsers = [];
    try {
      const parsersResponse = await httpRequest(`${webUrl}/api/parsers`, {
        method: 'GET',
      });
      if (parsersResponse.ok) {
        availableParsers = await parsersResponse.json();
      } else {
        console.warn('  ‚ö†Ô∏è  Failed to fetch parsers from API, using fallback list');
      }
    } catch (e) {
      console.warn('  ‚ö†Ô∏è  Failed to fetch parsers from API, using fallback list');
    }
    
    // Fallback to hardcoded list if API fails or returns empty
    if (!availableParsers || availableParsers.length === 0) {
      availableParsers = [
        { id: 'nginx', name: 'Nginx Access Log', category: 'web' },
        { id: 'apache', name: 'Apache Access Log', category: 'web' },
        { id: 'docker', name: 'Docker Container Logs', category: 'system' },
        { id: 'kubernetes', name: 'Kubernetes Pod/Container Logs', category: 'system' },
      ];
    }
    
    // Mandatory parsers that are always included
    const mandatoryParserIds = ['json-in-text', 'raw', 'keyvalue', 'stacktrace', 'smart-pattern'];
    
    // Filter out mandatory parsers for selection (only optional parsers can be selected)
    const selectableParsers = availableParsers.filter(p => !mandatoryParserIds.includes(p.id) && !p.isMandatory);
    
    // Pre-select mandatory parsers
    let enabledParsers = [...mandatoryParserIds];
    
    console.log('  Mandatory parsers are automatically included:');
    mandatoryParserIds.forEach(id => {
      const parser = availableParsers.find(p => p.id === id);
      if (parser) {
        console.log(`    ‚úì ${parser.name}`);
      }
    });
    console.log('');
    
    console.log('  Select additional optional parsers (leave empty for mandatory only):');
    if (selectableParsers.length > 0) {
      console.log('  Available optional parsers:');
      selectableParsers.forEach((p, i) => {
        console.log(`    ${i + 1}. ${p.name} (${p.id})`);
      });
      console.log('    (Leave empty for mandatory parsers only)\n');
    } else {
      console.log('  No additional optional parsers available.\n');
    }
    
    const answer = await question('  Enter comma-separated numbers or parser IDs (e.g., 1,2 or docker,kubernetes): ');
    rl.close();
    
    if (answer.trim()) {
      const selections = answer.split(',').map(s => s.trim());
      selections.forEach(sel => {
        // Check if it's a number
        const num = parseInt(sel, 10);
        if (!isNaN(num) && num > 0 && num <= selectableParsers.length) {
          enabledParsers.push(selectableParsers[num - 1].id);
        } else if (selectableParsers.find(p => p.id === sel)) {
          enabledParsers.push(sel);
        }
      });
    }
    
    // Use parser flag if provided, otherwise use interactive selection
    const parserFlag = options.parser || options.parsers;
    if (parserFlag) {
      if (typeof parserFlag === 'string') {
        // Add optional parsers from flag, but always include mandatory
        const flagParsers = parserFlag.split(',').map(p => p.trim());
        enabledParsers = [...new Set([...mandatoryParserIds, ...flagParsers])];
      }
    }
    
    // Get token - required for authenticated session creation
    let token = process.env.VIBEX_TOKEN || await getStoredToken();
    const tokenSource = process.env.VIBEX_TOKEN ? 'cli-env' : 'cli-config';
    if (!token) {
      console.error('\n  ‚úó Authentication required');
      console.error('  üí° Run: npx vibex-sh login');
      process.exit(1);
    }
    
    // Create session with enabledParsers (authenticated)
    const createUrl = `${webUrl}/api/sessions/create`;
    const response = await httpRequest(createUrl, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        'X-Token-Source': tokenSource,
      },
      body: JSON.stringify({
        enabledParsers: enabledParsers.length > 0 ? enabledParsers : undefined,
      }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      if (response.status === 401 || response.status === 403) {
        console.error(`\n  ‚úó Authentication failed: ${errorData.message || 'Invalid token'}`);
        console.error('  üí° Run: npx vibex-sh login');
      } else {
        console.error(`\n  ‚úó Failed to create session: ${errorData.message || 'Unknown error'}`);
      }
      process.exit(1);
    }
    
    const data = await response.json();
    const createdSessionId = data.sessionId;
    const createdAuthCode = data.authCode;
    
      console.log('\n  ‚úÖ Session created successfully!\n');
      printBanner(createdSessionId, createdAuthCode);
    
    // Separate mandatory and optional parsers for display
    const mandatoryIncluded = enabledParsers.filter(id => mandatoryParserIds.includes(id));
    const optionalIncluded = enabledParsers.filter(id => !mandatoryParserIds.includes(id));
    
    if (mandatoryIncluded.length > 0) {
      console.log(`  üìã Mandatory parsers: ${mandatoryIncluded.join(', ')}`);
    }
    if (optionalIncluded.length > 0) {
      console.log(`  üìã Optional parsers: ${optionalIncluded.join(', ')}`);
    } else if (mandatoryIncluded.length === mandatoryParserIds.length) {
      console.log('  üìã Using mandatory parsers only');
    }
    console.log(`\n  üí° Use this session ID: ${createdSessionId}`);
    console.log(`  Example: echo '{"cpu": 45}' | npx vibex-sh -s ${createdSessionId}\n`);
    
    process.exit(0);
  } catch (error) {
    rl.close();
    console.error(`\n  ‚úó Error: ${error.message}`);
    process.exit(1);
  }
}

async function main() {
  // Configure main program
  program
    .name('vibex')
    .description('vibex.sh CLI - Send logs to vibex.sh for real-time analysis')
    .version(cliVersion, '-v, --version', 'Display version number');

  // Login command
  program
    .command('login')
    .description('Authenticate with vibex.sh and save your token')
    .action(async () => {
      await handleLogin();
      process.exit(0);
    });

  // Init command
  program
    .command('init')
    .description('Create a new session with parser selection')
    .option('--parser <parsers>', 'Comma-separated list of parser IDs (e.g., nginx,postgres)')
    .option('--parsers <parsers>', 'Alias for --parser')
    .action(async (options) => {
      await handleInit(options);
    });

  // Main command (default) - send logs
  program
    .option('-s, --session-id <id>', 'Reuse existing session ID')
    .option('--token <token>', 'Authentication token (or use VIBEX_TOKEN env var)')
    .option('--parser <parsers>', 'Comma-separated list of parser IDs (e.g., nginx,postgres)')
    .option('--parsers <parsers>', 'Alias for --parser')
    .action(async (options) => {
      await handleSendLogs(options);
    });

  // Parse arguments
  program.parse();
}

/**
 * Handle send logs command (default/main command)
 */
async function handleSendLogs(options) {
  const { webUrl } = getProductionUrls();
  
  // Get token - REQUIRED for all operations
  // Track token source for debugging
  let token;
  let tokenSource = 'cli-config'; // default
  if (options.token) {
    token = options.token;
    tokenSource = 'cli-option';
  } else if (process.env.VIBEX_TOKEN) {
    token = process.env.VIBEX_TOKEN;
    tokenSource = 'cli-env';
  } else {
    token = await getStoredToken();
    tokenSource = 'cli-config';
  }
  
  if (!token) {
    console.error('\n  ‚úó Authentication required');
    console.error('  üí° Run: npx vibex-sh login to authenticate');
    console.error('  üí° Or set VIBEX_TOKEN environment variable\n');
    process.exit(1);
  }
  
  let sessionId;
  let authCode = null;
  
  // Check if stdin is available (piped input)
  const isTTY = process.stdin.isTTY;
  const hasStdin = !isTTY;
  
  // If no session ID and no stdin, show usage and exit
  if (!options.sessionId && !hasStdin) {
    program.help();
    process.exit(0);
  }
  
  // If session ID is provided, use it (existing session)
  if (options.sessionId) {
    sessionId = normalizeSessionId(options.sessionId);
    
    // When reusing a session, show minimal info
    if (hasStdin) {
      console.log(chalk.cyan(`\n  üîç Sending logs to session: ${chalk.bold(sessionId)}\n`));
    } else {
      console.log(chalk.cyan(`  üîç Session: ${chalk.bold(sessionId)}\n`));
    }
  } else {
    // No session ID provided - create a new authenticated session
    // Check for --parser or --parsers flag for parser selection
    let enabledParsers = [];
    if (options.parser || options.parsers) {
      const parserList = options.parser || options.parsers;
      if (Array.isArray(parserList)) {
        enabledParsers = parserList;
      } else if (typeof parserList === 'string') {
        enabledParsers = parserList.split(',').map(p => p.trim());
      }
    }
    
    try {
      const createUrl = `${webUrl}/api/sessions/create`;
      // Determine token source for this request
      const requestTokenSource = options.token ? 'cli-option' : (process.env.VIBEX_TOKEN ? 'cli-env' : 'cli-config');
      const response = await httpRequest(createUrl, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
          'X-Token-Source': requestTokenSource,
        },
        body: JSON.stringify({
          enabledParsers: enabledParsers.length > 0 ? enabledParsers : undefined,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        if (response.status === 401 || response.status === 403) {
          console.error(`  ‚úó Authentication failed: ${errorData.message || 'Invalid token'}`);
          console.error('  üí° Run: npx vibex-sh login');
        } else {
          console.error(`  ‚úó Failed to create session: ${errorData.message || 'Unknown error'}`);
        }
        process.exit(1);
      }
      
      const data = await response.json();
      sessionId = data.sessionId; // Server-generated unique session ID
      authCode = data.authCode; // Server-generated auth code
      
      // Print banner for new session
      printBanner(sessionId, authCode);
      if (enabledParsers.length > 0) {
        console.log(`  üìã Log Types: ${enabledParsers.join(', ')}`);
      } else {
        console.log('  üìã Log Types: Auto-detection (default parsers)');
      }
      console.log('  üí° Tip: Use -s to send more logs to this session');
      console.log(`  Example: echo '{"cpu": 45, "memory": 78}' | npx vibex-sh -s ${sessionId}\n`);
    } catch (error) {
      console.error(`  ‚úó Error creating session: ${error.message}`);
      process.exit(1);
    }
  }

  // Store auth code from session creation
  const receivedAuthCode = authCode;

  // Stats tracking for piped input (declared early so sendLogViaHTTP can access it)
  let stats = {
    logsRead: 0,
    logsSent: 0,
    logsFailed: 0,
    startTime: Date.now(),
  };

  // Progress bar for piped input (declared early so sendLogViaHTTP can access it)
  let progressBar = null;
  if (hasStdin) {
    progressBar = new cliProgress.SingleBar({
      format: chalk.cyan('{bar}') + ' | ' + chalk.white('{percentage}%') + ' | ' + chalk.green('{value}/{total}') + ' logs sent | ' + chalk.blue('{eta}s remaining'),
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true,
      clearOnComplete: false,
      etaBuffer: 10,
    });
    // Start with 1 to avoid division by zero, will update as we read logs
    progressBar.start(1, 0, {
      value: 0,
      total: 1,
    });
  }


  // Send logs via HTTP POST (non-blocking, same as SDKs)
  // Always use production Cloudflare Worker endpoint
  // Token is REQUIRED - all sessions must be authenticated
  // All logs are sent via HTTP POST
  const sendLogViaHTTP = async (logData, suppressOutput = false) => {
    try {
      // Always use production worker URL
      const workerUrl = process.env.VIBEX_WORKER_URL || DEFAULT_WORKER_URL;
      const ingestUrl = `${workerUrl}/api/v1/ingest`;
            
      // Build headers - Authorization is REQUIRED
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        'X-Token-Source': tokenSource, // Track token origin for debugging
      };
      
      const response = await fetch(ingestUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          sessionId,
          logs: [logData],
        }),
      });

      if (!response.ok) {
        stats.logsFailed++;
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.message || response.statusText || 'Unknown error';
        
        if (!suppressOutput) {
          console.error(chalk.red(`\n  ‚úó HTTP ${response.status}: ${errorMessage}`));
        }
        
        // Handle specific error cases
        if (response.status === 401) {
          if (!suppressOutput) {
            if (errorMessage.includes('expired')) {
              console.error(chalk.yellow('\n  üîë Token Expired'));
              console.error('  Your authentication token has expired.');
              console.error(chalk.cyan('  üí° Run: npx vibex-sh login'));
              console.error('');
            } else if (errorMessage.includes('Invalid') || errorMessage.includes('invalid')) {
              console.error(chalk.yellow('\n  üîë Invalid Token'));
              console.error('  Your authentication token is invalid or missing.');
              console.error(chalk.cyan('  üí° Run: npx vibex-sh login'));
              console.error('');
            } else {
              console.error(chalk.yellow('\n  üîë Unauthorized'));
              console.error(`  ${errorMessage}`);
              console.error(chalk.cyan('  üí° Run: npx vibex-sh login'));
              console.error('');
            }
          }
        } else if (response.status === 400) {
          if (!suppressOutput) {
            console.error(chalk.yellow('\n  üìù Bad Request'));
            console.error(`  ${errorMessage}`);
            if (errorMessage.includes('sessionId')) {
              console.error(chalk.cyan('  üí° Make sure you provided a valid session ID with -s or --session'));
            } else if (errorMessage.includes('logs')) {
              console.error(chalk.cyan('  üí° Make sure you are sending valid log data'));
            }
            console.error('');
          }
        } else if (response.status === 403) {
          if (!suppressOutput) {
            if (errorMessage.includes('History Limit')) {
              console.error(chalk.yellow('\n  üö´ History Limit Reached'));
              console.error(`  ${errorMessage}`);
              if (errorData.upgradeRequired) {
                console.error(chalk.cyan('  üí° Upgrade to Pro to unlock 30 days retention'));
                console.error(chalk.cyan('  üåê Visit: https://vibex.sh/pricing'));
              }
              console.error('');
            } else if (errorMessage.includes('access') || errorMessage.includes('belongs')) {
              console.error(chalk.yellow('\n  üö´ Access Denied'));
              console.error(`  ${errorMessage}`);
              console.error(chalk.cyan('  üí° This session belongs to another user or is not accessible'));
              console.error(chalk.cyan('  üí° Make sure you are using the correct token and session ID'));
              console.error('');
            } else if (errorMessage.includes('archived')) {
              console.error(chalk.yellow('\n  üö´ Session Archived'));
              console.error(`  ${errorMessage}`);
              console.error(chalk.cyan('  üí° This session is archived and cannot accept new logs'));
              console.error('');
            } else {
              console.error(chalk.yellow('\n  üö´ Forbidden'));
              console.error(`  ${errorMessage}`);
              console.error('');
            }
          }
        } else if (response.status === 404) {
          if (!suppressOutput) {
            console.error(chalk.yellow('\n  üîç Session Not Found'));
            console.error(`  ${errorMessage}`);
            console.error(chalk.cyan('  üí° Make sure the session ID is correct'));
            console.error(chalk.cyan('  üí° Check if the session exists in your dashboard'));
            console.error('');
          }
        } else if (response.status === 429) {
          if (!suppressOutput) {
            console.error(chalk.yellow('\n  ‚ö†Ô∏è  Rate Limit Exceeded'));
            console.error(`  ${errorMessage}`);
            if (errorData.retryAfter) {
              console.error(chalk.cyan(`  ‚è±Ô∏è  Retry after: ${errorData.retryAfter} seconds`));
            }
            console.error('');
          }
        } else if (response.status >= 500) {
          if (!suppressOutput) {
            console.error(chalk.red('\n  üî¥ Server Error'));
            console.error(`  ${errorMessage}`);
            console.error(chalk.cyan('  üí° This is a server-side issue. Please try again later.'));
            console.error(chalk.cyan('  üí° If the problem persists, contact support'));
            console.error('');
          }
        } else {
          if (!suppressOutput) {
            console.error(`  ${errorMessage}`);
            console.error('');
          }
        }
      } else {
        stats.logsSent++;
        const result = await response.json().catch(() => ({}));
        
        // Update progress bar if available
        if (progressBar && suppressOutput) {
          const total = Math.max(stats.logsRead, 1);
          progressBar.setTotal(total);
          progressBar.update(stats.logsSent, {
            value: stats.logsSent,
            total: total,
          });
        } else if (!suppressOutput) {
          console.log(chalk.green(`  ‚úì Log sent successfully (processed: ${result.processed || 1})`));
        }
      }
    } catch (error) {
      stats.logsFailed++;
      if (!suppressOutput) {
        console.error(chalk.red(`  ‚úó Error sending log: ${error.message}`));
      }
    }
  };

  // Only read from stdin if we have piped input
  if (!hasStdin) {
    // No stdin - exit after showing session info
    process.exit(0);
  }

  // Rate limiting queue for piped input
  const pipedLogQueue = [];
  let isProcessingQueue = false;
  let queueProcessingTimeout = null;

  const processPipedLogQueue = async () => {
    if (isProcessingQueue) {
      return;
    }

    if (pipedLogQueue.length === 0) {
      return;
    }

    isProcessingQueue = true;

    try {
      while (pipedLogQueue.length > 0) {
        const logData = pipedLogQueue.shift();
        await sendLogViaHTTP(logData, true); // Suppress output for piped input
        
        // Wait before sending the next log (only if there are more logs in queue)
        if (pipedLogQueue.length > 0) {
          await new Promise(resolve => setTimeout(resolve, PIPED_INPUT_DELAY_MS));
        }
      }
    } finally {
      isProcessingQueue = false;
    }
  };

  const queuePipedLog = (logData) => {
    pipedLogQueue.push(logData);
    
    // Start processing if not already processing
    if (!isProcessingQueue) {
      // Clear any existing timeout
      if (queueProcessingTimeout) {
        clearTimeout(queueProcessingTimeout);
        queueProcessingTimeout = null;
      }
      // Process queue with a small initial delay to batch rapid inputs
      queueProcessingTimeout = setTimeout(() => {
        processPipedLogQueue().catch((error) => {
          console.error('  ‚úó Error processing log queue:', error.message);
        });
      }, 10);
    }
  };

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  });

  rl.on('line', (line) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      return;
    }

    // Track stats
    stats.logsRead++;
    
    // Update progress bar total
    if (progressBar) {
      // Ensure total is at least 1 to avoid division by zero
      const total = Math.max(stats.logsRead, 1);
      progressBar.setTotal(total);
      progressBar.update(stats.logsSent, {
        value: stats.logsSent,
        total: total,
      });
    }

    let logData;
    try {
      const parsed = JSON.parse(trimmedLine);
      // Phase 1.8: Normalize JSON to hybrid structure
      if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
        const hybrid = normalizeToHybrid(null, null, parsed);
        logData = {
          type: 'json',
          payload: hybrid,
          timestamp: Date.now(),
        };
      } else {
        // Parsed but not an object - treat as text
        logData = {
          type: 'json',
          payload: {
            message: trimmedLine,
            level: 'debug',
            metrics: {},
            context: {},
          },
          timestamp: Date.now(),
        };
      }
    } catch (e) {
      // Phase 1.8: Text logs are now valuable - send as message field
      logData = {
        type: 'json',
        payload: {
          message: trimmedLine,
          level: 'debug',
          metrics: {},
          context: {},
        },
        timestamp: Date.now(),
      };
    }

    // Queue logs for rate-limited sending when input is piped
    // This prevents overwhelming rate limits when piping large files
    queuePipedLog(logData);
  });

  rl.on('close', async () => {
    // Clear any pending queue processing timeout
    if (queueProcessingTimeout) {
      clearTimeout(queueProcessingTimeout);
      queueProcessingTimeout = null;
    }
    
    // Process any remaining logs in the piped queue
    // Keep processing until queue is empty and not currently processing
    while (pipedLogQueue.length > 0 || isProcessingQueue) {
      await processPipedLogQueue();
      // Small delay to allow processing to complete
      if (pipedLogQueue.length > 0 || isProcessingQueue) {
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }
    
    // Stop progress bar and show summary
    if (progressBar) {
      progressBar.stop();
      console.log(''); // New line after progress bar
    }
    
    // Show summary
    const duration = ((Date.now() - stats.startTime) / 1000).toFixed(1);
    const { webUrl } = getProductionUrls();
    const dashboardUrl = receivedAuthCode 
      ? `${webUrl}/${sessionId}?auth=${receivedAuthCode}`
      : `${webUrl}/${sessionId}`;
    
    console.log(chalk.cyan('  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'));
    console.log(chalk.cyan('  ‚ïë         ‚úì Upload Complete             ‚ïë'));
    console.log(chalk.cyan('  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù'));
    console.log('');
    console.log(chalk.white(`  üìä Stats:`));
    console.log(chalk.green(`     ‚Ä¢ Logs read:    ${stats.logsRead}`));
    console.log(chalk.green(`     ‚Ä¢ Logs sent:     ${stats.logsSent}`));
    if (stats.logsFailed > 0) {
      console.log(chalk.red(`     ‚Ä¢ Logs failed:   ${stats.logsFailed}`));
    }
    console.log(chalk.blue(`     ‚Ä¢ Duration:      ${duration}s`));
    console.log('');
    console.log(chalk.white(`  üîó Dashboard: ${chalk.underline.cyan(dashboardUrl)}`));
    console.log('');
    
    
    // Give a moment for any final cleanup
    setTimeout(() => process.exit(0), 100);
  });

  process.on('SIGINT', async () => {
    if (progressBar) {
      progressBar.stop();
    }
    console.log(chalk.yellow('\n  ‚ö†Ô∏è  Interrupted by user\n'));
    
    // Show partial stats if available
    if (stats.logsRead > 0) {
      console.log(chalk.white(`  üìä Partial stats:`));
      console.log(chalk.green(`     ‚Ä¢ Logs read:    ${stats.logsRead}`));
      console.log(chalk.green(`     ‚Ä¢ Logs sent:     ${stats.logsSent}`));
      if (stats.logsFailed > 0) {
        console.log(chalk.red(`     ‚Ä¢ Logs failed:   ${stats.logsFailed}`));
      }
      console.log('');
    }
    
    process.exit(0);
  });
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

