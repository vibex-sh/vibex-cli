import readline from 'readline';
import { program, Command } from 'commander';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import { fileURLToPath } from 'url';
import WebSocket from 'ws';
import crypto from 'crypto';

// Get version from package.json
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJsonPath = join(__dirname, 'package.json');
let cliVersion = '0.0.0';
try {
  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
  cliVersion = packageJson.version || '0.0.0';
} catch (error) {
  // Fallback if package.json can't be read - try to read from parent directory
  try {
    const parentPackageJsonPath = join(__dirname, '..', 'package.json');
    const packageJson = JSON.parse(readFileSync(parentPackageJsonPath, 'utf8'));
    cliVersion = packageJson.version || '0.0.0';
  } catch (e) {
    // If both fail, use default
  }
}

// Session ID generation is now handled by the server
// This function is kept for backward compatibility but should not be used for new sessions
function generateSessionId() {
  // DEPRECATED: Session IDs should be generated by the server
  // This is only used as a fallback if server creation fails
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let result = 'vibex-';
  
  // Use crypto.randomBytes for cryptographically secure random generation
  const randomBytes = crypto.randomBytes(12);
  for (let i = 0; i < 12; i++) {
    result += chars[randomBytes[i] % chars.length];
  }
  
  return result;
}

function normalizeSessionId(sessionId) {
  if (!sessionId) return null;
  // If it doesn't start with 'vibex-', add it
  if (!sessionId.startsWith('vibex-')) {
    return `vibex-${sessionId}`;
  }
  return sessionId;
}

/**
 * Phase 1.8: Log Normalization for CLI
 * Intelligently transforms log data into hybrid JSON structure
 */

function normalizeLevel(level) {
  if (!level) return 'debug';
  const levelStr = String(level).toLowerCase();
  if (['debug', 'dbg', 'trace'].includes(levelStr)) return 'debug';
  if (['info', 'information', 'log'].includes(levelStr)) return 'info';
  if (['warn', 'warning', 'wrn'].includes(levelStr)) return 'warn';
  if (['error', 'err', 'exception', 'fatal', 'critical'].includes(levelStr)) return 'error';
  return 'debug';
}

function extractMetrics(payload) {
  const metrics = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return metrics;
  }
  if (payload.metrics && typeof payload.metrics === 'object' && !Array.isArray(payload.metrics)) {
    for (const [key, value] of Object.entries(payload.metrics)) {
      if (typeof value === 'number') {
        metrics[key] = value;
      }
    }
    return metrics;
  }
  const knownContextFields = new Set([
    'trace_id', 'traceId', 'user_id', 'userId', 'request_id', 'requestId',
    'correlation_id', 'correlationId', 'span_id', 'spanId', 'session_id', 'sessionId',
    'id', 'pid', 'port', 'year', 'timestamp', 'time', 'date', 'createdAt', 'updatedAt',
    'datetime', 'ts', 'utc', 'iso', 'exc_info', 'exception', 'error', 'message', 'msg', 'level', 'severity', 'log_level'
  ]);
  for (const [key, value] of Object.entries(payload)) {
    const keyLower = key.toLowerCase();
    if (knownContextFields.has(keyLower)) continue;
    if (keyLower.includes('timestamp') || keyLower.includes('time') || keyLower.includes('date')) continue;
    if (typeof value === 'number') {
      if (key.endsWith('_ms') || key.endsWith('_count') || key.endsWith('_size') ||
          key.endsWith('Ms') || key.endsWith('Count') || key.endsWith('Size') ||
          ['cpu', 'memory', 'latency', 'response_time', 'duration'].some(pattern => keyLower.includes(pattern))) {
        metrics[key] = value;
      }
    }
  }
  return metrics;
}

function extractContext(payload) {
  const context = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return context;
  }
  if (payload.context && typeof payload.context === 'object' && !Array.isArray(payload.context)) {
    return payload.context;
  }
  const knownContextFields = {
    'trace_id': 'trace_id', 'traceId': 'trace_id',
    'user_id': 'user_id', 'userId': 'user_id',
    'request_id': 'request_id', 'requestId': 'request_id',
    'correlation_id': 'correlation_id', 'correlationId': 'correlation_id',
    'span_id': 'span_id', 'spanId': 'span_id',
    'session_id': 'session_id', 'sessionId': 'session_id',
  };
  for (const [field, normalizedKey] of Object.entries(knownContextFields)) {
    if (payload[field] !== undefined) {
      context[normalizedKey] = payload[field];
    }
  }
  return context;
}

function normalizeToHybrid(message, level, payload) {
  const merged = { ...(payload || {}) };
  let normalizedMessage = message;
  if (!normalizedMessage && merged.message) normalizedMessage = merged.message;
  if (!normalizedMessage && merged.msg) normalizedMessage = merged.msg;
  const normalizedLevel = normalizeLevel(level || merged.level || merged.severity || merged.log_level);
  const metrics = extractMetrics(merged);
  const context = extractContext(merged);
  const annotation = merged._annotation;
  const hybrid = {
    message: normalizedMessage, // Can be null/undefined
    level: normalizedLevel,
    metrics: metrics,
    context: context,
  };
  if (annotation) hybrid._annotation = annotation;
  for (const [key, value] of Object.entries(merged)) {
    if (!['message', 'msg', 'level', 'severity', 'log_level', 'metrics', 'context', '_annotation'].includes(key)) {
      if (!(key in hybrid)) hybrid[key] = value;
    }
  }
  return hybrid;
}

function deriveSocketUrl(webUrl) {
  // Always use production worker WebSocket endpoint
  const workerUrl = process.env.VIBEX_WORKER_URL || 'https://ingest.vibex.sh';
  return workerUrl.replace('https://', 'wss://').replace('http://', 'ws://');
}

function getUrls(options) {
  const { web, socket, server } = options;
  
  // Priority 1: Explicit --web and --socket flags (highest priority)
  if (web) {
    return {
      webUrl: web,
      socketUrl: socket || deriveSocketUrl(web),
    };
  }
  
  // Priority 2: --server flag (shorthand for --web)
  if (server) {
    return {
      webUrl: server,
      socketUrl: socket || deriveSocketUrl(server),
    };
  }
  
  // Priority 3: Environment variables
  if (process.env.VIBEX_WEB_URL) {
    return {
      webUrl: process.env.VIBEX_WEB_URL,
      socketUrl: process.env.VIBEX_SOCKET_URL || socket || deriveSocketUrl(process.env.VIBEX_WEB_URL),
    };
  }
  
  // Priority 4: Production defaults
  // Always use production worker WebSocket endpoint
  const defaultWorkerUrl = process.env.VIBEX_WORKER_URL || 'https://ingest.vibex.sh';
  return {
    webUrl: 'https://vibex.sh',
    socketUrl: socket || defaultWorkerUrl.replace('https://', 'wss://').replace('http://', 'ws://'),
  };
}

function getConfigPath() {
  // Check for custom config path from environment variable
  if (process.env.VIBEX_CONFIG_PATH) {
    return process.env.VIBEX_CONFIG_PATH;
  }
  // Default: ~/.vibex/config.json
  const configDir = join(homedir(), '.vibex');
  return join(configDir, 'config.json');
}

async function getStoredToken() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      const config = JSON.parse(await readFile(configPath, 'utf-8'));
      return config.token || null;
    }
  } catch (error) {
    // Ignore errors (file doesn't exist or invalid JSON)
  }
  return null;
}

function getStoredConfig() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
  } catch (error) {
    // Ignore errors
  }
  return null;
}

async function storeToken(token, webUrl = null) {
  try {
    const configPath = getConfigPath();
    const configDir = join(homedir(), '.vibex');
    if (!existsSync(configDir)) {
      await mkdir(configDir, { recursive: true });
    }
    
    const config = {
      token,
      ...(webUrl && { webUrl }), // Store webUrl if provided
      updatedAt: new Date().toISOString(),
    };
    
    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');
    return true;
  } catch (error) {
    console.error('Failed to store token:', error.message);
    return false;
  }
}

async function handleLogin(webUrl) {
  const configPath = getConfigPath();
  const existingConfig = getStoredConfig();
  
  console.log('\n  üîê vibex.sh CLI Authentication\n');
  console.log(`  üìÅ Config location: ${configPath}`);
  
  if (existingConfig?.token) {
    console.log(`  ‚ö†Ô∏è  You already have a token stored. This will replace it.\n`);
  }
  
  const tempToken = `temp_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  const authUrl = `${webUrl}/api/cli-auth?token=${tempToken}`;
  
  console.log('  Opening browser for authentication...\n');
  console.log(`  If browser doesn't open, visit: ${authUrl}\n`);
  
  // Open browser
  const platform = process.platform;
  let command;
  if (platform === 'darwin') {
    command = 'open';
  } else if (platform === 'win32') {
    command = 'start';
  } else {
    command = 'xdg-open';
  }
  
  spawn(command, [authUrl], { detached: true, stdio: 'ignore' });
  
  // Poll for token
  console.log('  Waiting for authentication...');
  const maxAttempts = 60; // 60 seconds
  let attempts = 0;
  
  while (attempts < maxAttempts) {
    await new Promise(resolve => setTimeout(resolve, 1000));
    attempts++;
    
    try {
      const response = await httpRequest(`${webUrl}/api/cli-auth?token=${tempToken}`, {
        method: 'GET',
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          await storeToken(data.token, webUrl);
          const configPath = getConfigPath();
          console.log('\n  ‚úÖ Authentication successful!');
          console.log(`  üìÅ Token saved to: ${configPath}`);
          console.log(`  üí° This token will be used automatically for future commands.\n`);
          return data.token;
        }
      }
    } catch (error) {
      // Continue polling
    }
  }
  
  console.log('\n  ‚è±Ô∏è  Authentication timeout. Please try again.\n');
  process.exit(1);
}

function httpRequest(url, options) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === 'https:';
    const httpModule = isHttps ? https : http;
    
    const req = httpModule.request(url, options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve(parsed) });
        } catch (e) {
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve({}) });
        }
      });
    });
    
    req.on('error', reject);
    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}

async function claimSession(sessionId, token, webUrl) {
  if (!token) return null; // Return null instead of false to indicate no claim attempted
  
  try {
    // Normalize session ID before claiming
    const normalizedSessionId = normalizeSessionId(sessionId);
    const response = await httpRequest(`${webUrl}/api/auth/claim-session-with-token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionId: normalizedSessionId,
        token,
      }),
    });
    
    if (response.ok) {
      // Parse response to get auth code
      const responseData = await response.json();
      return responseData.authCode || null;
    }
    
    return null;
  } catch (error) {
    return null;
  }
}

// Removed getSessionAuthCode - auth codes should only come from:
// 1. claim-session-with-token response (for claimed sessions)
// 2. socket.io session-auth-code event (for unclaimed sessions)
// Never fetch auth codes via public API endpoint - security vulnerability 

function printBanner(sessionId, webUrl, authCode = null) {
  const dashboardUrl = authCode 
    ? `${webUrl}/${sessionId}?auth=${authCode}`
    : `${webUrl}/${sessionId}`;
  
  console.log('\n');
  console.log('  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('  ‚ïë         üîç vibex.sh is watching...    ‚ïë');
  console.log('  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('\n');
  console.log(`  Session ID: ${sessionId}`);
  if (authCode) {
    console.log(`  Auth Code:  ${authCode}`);
  }
  console.log(`  Dashboard:  ${dashboardUrl}`);
  console.log('\n');
}

async function main() {
  // Handle --version flag early (before commander parses)
  const allArgs = process.argv;
  const args = process.argv.slice(2);
  
  // Check for --version or -V flag
  if (allArgs.includes('--version') || allArgs.includes('-V') || args.includes('--version') || args.includes('-V')) {
    console.log(cliVersion);
    process.exit(0);
  }
  
  // Handle login command separately - check BEFORE commander parses
  // Check process.argv directly - look for 'login' as a standalone argument
  // This must happen FIRST, before any commander parsing
  // Check if 'login' appears anywhere in process.argv (works with npx too)
  const hasLogin = allArgs.includes('login') || args.includes('login');
  
  if (hasLogin) {
    // Find login position to get args after it
    const loginIndex = args.indexOf('login');
    const loginArgs = loginIndex !== -1 ? args.slice(loginIndex + 1) : [];
    
    // Create a separate command instance for login
    const loginCmd = new Command();
    loginCmd
      .option('--web <url>', 'Web server URL')
      .option('--server <url>', 'Shorthand for --web');
    
    // Parse only the options (args after 'login')
    if (loginArgs.length > 0) {
      loginCmd.parse(['node', 'vibex', ...loginArgs], { from: 'user' });
    } else {
      loginCmd.parse(['node', 'vibex'], { from: 'user' });
    }
    
    const options = loginCmd.opts();
    const { webUrl } = getUrls(options);
    await handleLogin(webUrl);
    process.exit(0);
  }

  program
    .version(cliVersion, '-v, --version', 'Display version number')
    .option('-s, --session-id <id>', 'Reuse existing session ID')
    .option('--web <url>', 'Web server URL')
    .option('--socket <url>', 'Socket server URL')
    .option('--server <url>', 'Shorthand for --web (auto-derives socket URL)')
    .option('--token <token>', 'Authentication token (or use VIBEX_TOKEN env var)')
    .parse();

  const options = program.opts();
  const { webUrl, socketUrl } = getUrls(options);
  
  // Get token from flag, env var, or stored config
  let token = options.token || process.env.VIBEX_TOKEN || await getStoredToken();
  
  let sessionId;
  let authCode = null;
  
  // If session ID is provided, use it (existing session)
  if (options.sessionId) {
    sessionId = normalizeSessionId(options.sessionId);
    
    // If token is available, try to claim the session
    if (token) {
      authCode = await claimSession(sessionId, token, webUrl);
    }
    
    // When reusing a session, show minimal info
    console.log(`  üîç Sending logs to session: ${sessionId}\n`);
  } else {
    // No session ID provided - create a new anonymous session
    try {
      const createUrl = `${webUrl}/api/sessions/create-anonymous`;
      const response = await httpRequest(createUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        console.error(`  ‚úó Failed to create session: ${errorData.message || 'Unknown error'}`);
        process.exit(1);
      }
      
      const data = await response.json();
      sessionId = data.sessionId; // Server-generated unique session ID
      authCode = data.authCode; // Server-generated auth code
      
      // If token is available, claim the session
      if (token) {
        const claimAuthCode = await claimSession(sessionId, token, webUrl);
        if (claimAuthCode) {
          authCode = claimAuthCode;
          console.log('  ‚úì Session automatically claimed to your account\n');
        }
      }
      
      // Print banner for new session
      printBanner(sessionId, webUrl, authCode);
      console.log('  üí° Tip: Use -s to send more logs to this session');
      console.log(`  Example: echo '{"cpu": 45, "memory": 78}' | npx vibex-sh -s ${sessionId}\n`);
    } catch (error) {
      console.error(`  ‚úó Error creating session: ${error.message}`);
      process.exit(1);
    }
  }

  let socket = null;
  let isConnected = false;
  let hasJoinedSession = false;
  const logQueue = [];
  let reconnectTimeout = null;
  let reconnectAttempts = 0;
  const maxReconnectDelay = 5000;

  // Connection state management
  let connectionState = 'disconnected'; // disconnected, connecting, connected, closing, closed
  let connectionEstablished = false;
  let connectionLock = false;
  let connectionStartTime = null;

  // Store auth code received from socket
  let receivedAuthCode = authCode;
  
  // Track if this is a new session (not reusing an existing one)
  const isNewSession = !options.sessionId;

  // Graceful shutdown function
  const closeWebSocket = () => {
    return new Promise((resolve) => {
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        if (connectionState === 'connected' || connectionState === 'closing') {
          connectionState = 'closed';
        }
        resolve();
        return;
      }
      
      connectionState = 'closing';
      const closeStartTime = Date.now();
      console.log('  üîÑ Initiating graceful WebSocket close...');
      
      const closeTimeout = setTimeout(() => {
        const elapsed = Date.now() - closeStartTime;
        console.log(`  ‚ö†Ô∏è  Close handshake timeout after ${elapsed}ms, forcing exit`);
        connectionState = 'closed';
        resolve();
      }, 2000);
      
      // Store original onclose handler
      const originalOnClose = socket.onclose;
      
      socket.onclose = (event) => {
        clearTimeout(closeTimeout);
        const elapsed = Date.now() - closeStartTime;
        connectionState = 'closed';
        connectionEstablished = false;
        console.log(`  ‚úì WebSocket closed gracefully (code: ${event.code}, reason: ${event.reason || 'none'}, time: ${elapsed}ms)`);
        
        // Call original handler if it exists
        if (originalOnClose) {
          originalOnClose(event);
        }
        
        resolve();
      };
      
      socket.close(1000, 'Stream ended');
    });
  };

  const connectWebSocket = () => {
    // Prevent multiple simultaneous connections
    if (connectionLock) {
      console.log('  ‚ö†Ô∏è  Connection already in progress, skipping...');
      return;
    }
    
    if (connectionState === 'connected' || connectionState === 'connecting') {
      console.log(`  ‚ö†Ô∏è  Already ${connectionState}, skipping new connection...`);
      return;
    }
    
    // Clear any existing reconnect timeout to prevent duplicate connections
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    connectionLock = true;
    connectionState = 'connecting';
    connectionStartTime = Date.now();
    console.log('  üîÑ Connecting to WebSocket...');
    
    try {
      // Close existing socket if any (cleanup)
      if (socket && socket.readyState !== WebSocket.CLOSED) {
        try {
          socket.close();
        } catch (e) {
          // Ignore errors when closing
        }
      }
      
      socket = new WebSocket(`${socketUrl}?sessionId=${sessionId}`);

      socket.onopen = () => {
        const connectTime = Date.now() - connectionStartTime;
        connectionLock = false;
        connectionState = 'connected';
        isConnected = true;
        connectionEstablished = true;
        console.log(`  ‚úì Connected to server (${connectTime}ms)\n`);
        reconnectAttempts = 0;

        // Join session
        socket.send(JSON.stringify({
          type: 'join-session',
          sessionId,
        }));

        // Set hasJoinedSession immediately - HTTP POST doesn't need WebSocket
        hasJoinedSession = true;
        // Process any queued logs immediately
        while (logQueue.length > 0) {
          const logData = logQueue.shift();
          // Send logs via HTTP POST (non-blocking) instead of WebSocket
          // WebSocket is only for receiving logs
          sendLogViaHTTP(logData);
        }
      };

      socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          switch (message.type) {
            case 'join-session-ack':
              console.log('  ‚úì Joined session\n');
              break;

            case 'session-auth-code':
              if (message.data && message.data.sessionId === sessionId && message.data.authCode) {
                if (!receivedAuthCode || receivedAuthCode !== message.data.authCode) {
                  receivedAuthCode = message.data.authCode;
                  if (isNewSession) {
                    console.log(`  üîë Auth Code: ${receivedAuthCode}`);
                    console.log(`  üìã Dashboard: ${webUrl}/${sessionId}?auth=${receivedAuthCode}\n`);
                  }
                }
              }
              break;

            case 'log':
              // Logs are received via WebSocket but sent via HTTP
              break;

            case 'error':
              const errorType = message.error || 'Error';
              const errorMsg = message.message || 'An unexpected error occurred';
              const statusCode = message.statusCode || 0;
              
              // Handle specific error types
              if (errorType === 'Rate Limit Exceeded' || statusCode === 429) {
                console.error('\n  ‚ö†Ô∏è  Rate Limit Exceeded');
                console.error(`  ${errorMsg}`);
                if (message.retryAfter) {
                  console.error(`  ‚è±Ô∏è  Retry after: ${message.retryAfter} seconds`);
                }
                console.error('');
                logQueue.length = 0;
              } else if (errorType === 'History Limit Reached' || (statusCode === 403 && errorMsg.includes('History Limit'))) {
                console.error('\n  üö´ History Limit Reached');
                console.error(`  ${errorMsg}`);
                if (message.limit !== undefined && message.current !== undefined) {
                  console.error(`  Current: ${message.current} / ${message.limit} logs`);
                }
                if (message.upgradeRequired) {
                  console.error('  üí° Upgrade to Pro to unlock 30 days retention');
                  console.error('  üåê Visit: https://vibex.sh/pricing');
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 401 || errorType === 'Unauthorized') {
                if (errorMsg.includes('expired')) {
                  console.error('\n  üîë Token Expired');
                  console.error('  Your authentication token has expired.');
                  console.error('  üí° Run: npx vibex-sh login');
                } else {
                  console.error('\n  üîë Unauthorized');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° Run: npx vibex-sh login');
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 403 || errorType === 'Forbidden') {
                if (errorMsg.includes('access') || errorMsg.includes('belongs')) {
                  console.error('\n  üö´ Access Denied');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° This session belongs to another user or is not accessible');
                  console.error('  üí° Make sure you are using the correct token and session ID');
                } else if (errorMsg.includes('archived')) {
                  console.error('\n  üö´ Session Archived');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° This session is archived and cannot accept new logs');
                } else {
                  console.error('\n  üö´ Forbidden');
                  console.error(`  ${errorMsg}`);
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 404 || errorType === 'Not Found') {
                console.error('\n  üîç Session Not Found');
                console.error(`  ${errorMsg}`);
                console.error('  üí° Make sure the session ID is correct');
                console.error('  üí° Check if the session exists in your dashboard');
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 400 || errorType === 'Bad Request') {
                console.error('\n  üìù Bad Request');
                console.error(`  ${errorMsg}`);
                if (errorMsg.includes('sessionId')) {
                  console.error('  üí° Make sure you provided a valid session ID with -s or --session');
                } else if (errorMsg.includes('logs')) {
                  console.error('  üí° Make sure you are sending valid log data');
                }
                console.error('');
                logQueue.length = 0;
              } else if (statusCode >= 500 || errorType === 'Internal Server Error') {
                console.error('\n  üî¥ Server Error');
                console.error(`  ${errorMsg}`);
                console.error('  üí° This is a server-side issue. Please try again later.');
                console.error('  üí° If the problem persists, contact support');
                console.error('');
                logQueue.length = 0;
              } else {
                console.error('\n  ‚úó Error');
                console.error(`  ${errorType}: ${errorMsg}`);
                if (statusCode) {
                  console.error(`  Status Code: ${statusCode}`);
                }
                console.error('');
                logQueue.length = 0;
              }
              break;

            default:
              // Ignore unknown message types
              break;
          }
        } catch (error) {
          console.error('  ‚úó Error parsing message:', error.message);
        }
      };

      socket.onerror = (error) => {
        if (!isConnected) {
          console.error(`  ‚úó Connection error: ${error.message || 'websocket error'}`);
          console.error(`  ‚Üª Trying to connect to: ${socketUrl}`);
          console.error('  ‚Üª Retrying connection...\n');
        }
      };

      socket.onclose = (event) => {
        connectionLock = false;
        connectionState = 'closed';
        connectionEstablished = false;
        isConnected = false;
        hasJoinedSession = false;
        
        const connectionDuration = connectionStartTime ? Date.now() - connectionStartTime : 0;
        console.log(`  üìä Connection closed (code: ${event.code}, reason: ${event.reason || 'none'}, duration: ${connectionDuration}ms)`);

        // Reconnect logic - only if not a normal closure and not already closing
        if (event.code !== 1000 && connectionState !== 'closing') {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
          reconnectAttempts++;
          console.log(`  ‚Üª Reconnecting in ${delay}ms (attempt ${reconnectAttempts})...\n`);
          
          reconnectTimeout = setTimeout(() => {
            connectWebSocket();
          }, delay);
        } else if (event.code === 1000) {
          console.log('  ‚úì Normal closure, no reconnect needed\n');
        }
      };
    } catch (error) {
      connectionLock = false;
      connectionState = 'disconnected';
      connectionEstablished = false;
      console.error(`  ‚úó Error creating WebSocket: ${error.message}`);
      console.error(`  ‚Üª URL: ${socketUrl}`);
      // Retry connection
      reconnectTimeout = setTimeout(() => {
        connectWebSocket();
      }, 1000);
    }
  };

  // Send logs via HTTP POST (non-blocking, same as SDKs)
  // Always use production Cloudflare Worker endpoint
  // Token is optional - anonymous sessions can send logs without authentication
  // HTTP POST works independently of WebSocket - don't wait for WebSocket connection
  const sendLogViaHTTP = async (logData) => {
    try {
      // Always use production worker URL
      const workerUrl = process.env.VIBEX_WORKER_URL || 'https://ingest.vibex.sh';
      const ingestUrl = `${workerUrl}/api/v1/ingest`;
            
      // Build headers - only include Authorization if token exists
      const headers = {
        'Content-Type': 'application/json',
      };
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
      }
      
      const response = await fetch(ingestUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          sessionId,
          logs: [logData],
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.message || response.statusText || 'Unknown error';
        
        console.error(`\n  ‚úó HTTP ${response.status}: ${errorMessage}`);
        
        // Handle specific error cases
        if (response.status === 401) {
          if (errorMessage.includes('expired')) {
            console.error('\n  üîë Token Expired');
            console.error('  Your authentication token has expired.');
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          } else if (errorMessage.includes('Invalid') || errorMessage.includes('invalid')) {
            console.error('\n  üîë Invalid Token');
            console.error('  Your authentication token is invalid or missing.');
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          } else {
            console.error('\n  üîë Unauthorized');
            console.error(`  ${errorMessage}`);
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          }
        } else if (response.status === 400) {
          console.error('\n  üìù Bad Request');
          console.error(`  ${errorMessage}`);
          if (errorMessage.includes('sessionId')) {
            console.error('  üí° Make sure you provided a valid session ID with -s or --session');
          } else if (errorMessage.includes('logs')) {
            console.error('  üí° Make sure you are sending valid log data');
          }
          console.error('');
        } else if (response.status === 403) {
          if (errorMessage.includes('History Limit')) {
            console.error('\n  üö´ History Limit Reached');
            console.error(`  ${errorMessage}`);
            if (errorData.upgradeRequired) {
              console.error('  üí° Upgrade to Pro to unlock 30 days retention');
              console.error('  üåê Visit: https://vibex.sh/pricing');
            }
            console.error('');
          } else if (errorMessage.includes('access') || errorMessage.includes('belongs')) {
            console.error('\n  üö´ Access Denied');
            console.error(`  ${errorMessage}`);
            console.error('  üí° This session belongs to another user or is not accessible');
            console.error('  üí° Make sure you are using the correct token and session ID');
            console.error('');
          } else if (errorMessage.includes('archived')) {
            console.error('\n  üö´ Session Archived');
            console.error(`  ${errorMessage}`);
            console.error('  üí° This session is archived and cannot accept new logs');
            console.error('');
          } else {
            console.error('\n  üö´ Forbidden');
            console.error(`  ${errorMessage}`);
            console.error('');
          }
        } else if (response.status === 404) {
          console.error('\n  üîç Session Not Found');
          console.error(`  ${errorMessage}`);
          console.error('  üí° Make sure the session ID is correct');
          console.error('  üí° Check if the session exists in your dashboard');
          console.error('');
        } else if (response.status === 429) {
          console.error('\n  ‚ö†Ô∏è  Rate Limit Exceeded');
          console.error(`  ${errorMessage}`);
          if (errorData.retryAfter) {
            console.error(`  ‚è±Ô∏è  Retry after: ${errorData.retryAfter} seconds`);
          }
          console.error('');
        } else if (response.status >= 500) {
          console.error('\n  üî¥ Server Error');
          console.error(`  ${errorMessage}`);
          console.error('  üí° This is a server-side issue. Please try again later.');
          console.error('  üí° If the problem persists, contact support');
          console.error('');
        } else {
          console.error(`  ${errorMessage}`);
          console.error('');
        }
      } else {
        const result = await response.json().catch(() => ({}));
        console.log(`  ‚úì Log sent successfully (processed: ${result.processed || 1})`);
      }
    } catch (error) {
      console.error(`  ‚úó Error sending log to ${ingestUrl}:`, error.message);
    }
  };

  // Start WebSocket connection
  connectWebSocket();

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  });

  rl.on('line', (line) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      return;
    }

    let logData;
    try {
      const parsed = JSON.parse(trimmedLine);
      // Phase 1.8: Normalize JSON to hybrid structure
      if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
        const hybrid = normalizeToHybrid(null, null, parsed);
        logData = {
          type: 'json',
          payload: hybrid,
          timestamp: Date.now(),
        };
      } else {
        // Parsed but not an object - treat as text
        logData = {
          type: 'json',
          payload: {
            message: trimmedLine,
            level: 'debug',
            metrics: {},
            context: {},
          },
          timestamp: Date.now(),
        };
      }
    } catch (e) {
      // Phase 1.8: Text logs are now valuable - send as message field
      logData = {
        type: 'json',
        payload: {
          message: trimmedLine,
          level: 'debug',
          metrics: {},
          context: {},
        },
        timestamp: Date.now(),
      };
    }

    // Send logs via HTTP POST immediately - don't wait for WebSocket
    // WebSocket is only for receiving logs and auth codes, not required for sending
    sendLogViaHTTP(logData);
  });

  rl.on('close', async () => {
    // Wait for queued logs to be sent
    const waitForQueue = () => {
      return new Promise((resolve) => {
        if (logQueue.length === 0) {
          resolve();
        } else {
          setTimeout(() => waitForQueue().then(resolve), 100);
        }
      });
    };
    
    await waitForQueue();
    
    console.log('\n  Stream ended. Closing connection...\n');
    
    // Cancel any pending reconnection attempts
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    // Graceful shutdown - wait for close handshake
    await closeWebSocket();
    
    // Give a moment for any final cleanup
    setTimeout(() => process.exit(0), 100);
  });

  process.on('SIGINT', async () => {
    console.log('\n  Interrupted. Closing connection...\n');
    
    // Cancel any pending reconnection attempts
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    // Graceful shutdown
    await closeWebSocket();
    
    process.exit(0);
  });
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

