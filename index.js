import readline from 'readline';
import { program, Command } from 'commander';
import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import { spawn } from 'child_process';
import http from 'http';
import https from 'https';
import { fileURLToPath } from 'url';
import WebSocket from 'ws';
import crypto from 'crypto';

// Constants
const POLL_INTERVAL_MS = 1000;
const MAX_POLL_ATTEMPTS = 60;
const WEBSOCKET_CLOSE_TIMEOUT_MS = 2000;
const DEFAULT_WORKER_URL = 'https://ingest.vibex.sh';
const DEFAULT_WEB_URL = 'https://vibex.sh';

// Get version from package.json
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJsonPath = join(__dirname, 'package.json');
let cliVersion = '0.0.0';
try {
  const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf8'));
  cliVersion = packageJson.version || '0.0.0';
} catch (error) {
  // Fallback if package.json can't be read - try to read from parent directory
  try {
    const parentPackageJsonPath = join(__dirname, '..', 'package.json');
    const packageJson = JSON.parse(readFileSync(parentPackageJsonPath, 'utf8'));
    cliVersion = packageJson.version || '0.0.0';
  } catch (e) {
    // If both fail, use default
  }
}

// Session ID generation is now handled by the server
// This function is kept for backward compatibility but should not be used for new sessions
function generateSessionId() {
  // DEPRECATED: Session IDs should be generated by the server
  // This is only used as a fallback if server creation fails
  const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
  let result = 'vibex-';
  
  // Use crypto.randomBytes for cryptographically secure random generation
  const randomBytes = crypto.randomBytes(12);
  for (let i = 0; i < 12; i++) {
    result += chars[randomBytes[i] % chars.length];
  }
  
  return result;
}

function normalizeSessionId(sessionId) {
  if (!sessionId) return null;
  // If it doesn't start with 'vibex-', add it
  if (!sessionId.startsWith('vibex-')) {
    return `vibex-${sessionId}`;
  }
  return sessionId;
}

/**
 * Phase 1.8: Log Normalization for CLI
 * Intelligently transforms log data into hybrid JSON structure
 */

function normalizeLevel(level) {
  if (!level) return 'debug';
  const levelStr = String(level).toLowerCase();
  if (['debug', 'dbg', 'trace'].includes(levelStr)) return 'debug';
  if (['info', 'information', 'log'].includes(levelStr)) return 'info';
  if (['warn', 'warning', 'wrn'].includes(levelStr)) return 'warn';
  if (['error', 'err', 'exception', 'fatal', 'critical'].includes(levelStr)) return 'error';
  return 'debug';
}

function extractMetrics(payload) {
  const metrics = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return metrics;
  }
  if (payload.metrics && typeof payload.metrics === 'object' && !Array.isArray(payload.metrics)) {
    for (const [key, value] of Object.entries(payload.metrics)) {
      if (typeof value === 'number') {
        metrics[key] = value;
      }
    }
    return metrics;
  }
  const knownContextFields = new Set([
    'trace_id', 'traceId', 'user_id', 'userId', 'request_id', 'requestId',
    'correlation_id', 'correlationId', 'span_id', 'spanId', 'session_id', 'sessionId',
    'id', 'pid', 'port', 'year', 'timestamp', 'time', 'date', 'createdAt', 'updatedAt',
    'datetime', 'ts', 'utc', 'iso', 'exc_info', 'exception', 'error', 'message', 'msg', 'level', 'severity', 'log_level'
  ]);
  for (const [key, value] of Object.entries(payload)) {
    const keyLower = key.toLowerCase();
    if (knownContextFields.has(keyLower)) continue;
    if (keyLower.includes('timestamp') || keyLower.includes('time') || keyLower.includes('date')) continue;
    if (typeof value === 'number') {
      if (key.endsWith('_ms') || key.endsWith('_count') || key.endsWith('_size') ||
          key.endsWith('Ms') || key.endsWith('Count') || key.endsWith('Size') ||
          ['cpu', 'memory', 'latency', 'response_time', 'duration'].some(pattern => keyLower.includes(pattern))) {
        metrics[key] = value;
      }
    }
  }
  return metrics;
}

function extractContext(payload) {
  const context = {};
  if (!payload || typeof payload !== 'object' || Array.isArray(payload)) {
    return context;
  }
  if (payload.context && typeof payload.context === 'object' && !Array.isArray(payload.context)) {
    return payload.context;
  }
  const knownContextFields = {
    'trace_id': 'trace_id', 'traceId': 'trace_id',
    'user_id': 'user_id', 'userId': 'user_id',
    'request_id': 'request_id', 'requestId': 'request_id',
    'correlation_id': 'correlation_id', 'correlationId': 'correlation_id',
    'span_id': 'span_id', 'spanId': 'span_id',
    'session_id': 'session_id', 'sessionId': 'session_id',
  };
  for (const [field, normalizedKey] of Object.entries(knownContextFields)) {
    if (payload[field] !== undefined) {
      context[normalizedKey] = payload[field];
    }
  }
  return context;
}

function normalizeToHybrid(message, level, payload) {
  const merged = { ...(payload || {}) };
  let normalizedMessage = message;
  if (!normalizedMessage && merged.message) normalizedMessage = merged.message;
  if (!normalizedMessage && merged.msg) normalizedMessage = merged.msg;
  const normalizedLevel = normalizeLevel(level || merged.level || merged.severity || merged.log_level);
  const metrics = extractMetrics(merged);
  const context = extractContext(merged);
  const annotation = merged._annotation;
  const hybrid = {
    message: normalizedMessage, // Can be null/undefined
    level: normalizedLevel,
    metrics: metrics,
    context: context,
  };
  if (annotation) hybrid._annotation = annotation;
  for (const [key, value] of Object.entries(merged)) {
    if (!['message', 'msg', 'level', 'severity', 'log_level', 'metrics', 'context', '_annotation'].includes(key)) {
      if (!(key in hybrid)) hybrid[key] = value;
    }
  }
  return hybrid;
}

/**
 * Get production URLs
 * CLI only supports production server
 */
function getProductionUrls() {
  // Always use production worker WebSocket endpoint
  const workerUrl = process.env.VIBEX_WORKER_URL || DEFAULT_WORKER_URL;
  return {
    webUrl: DEFAULT_WEB_URL,
    socketUrl: workerUrl.replace('https://', 'wss://').replace('http://', 'ws://'),
  };
}

function getConfigPath() {
  // Check for custom config path from environment variable
  if (process.env.VIBEX_CONFIG_PATH) {
    return process.env.VIBEX_CONFIG_PATH;
  }
  // Default: ~/.vibex/config.json
  const configDir = join(homedir(), '.vibex');
  return join(configDir, 'config.json');
}

async function getStoredToken() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      const config = JSON.parse(await readFile(configPath, 'utf-8'));
      return config.token || null;
    }
  } catch (error) {
    // Ignore errors (file doesn't exist or invalid JSON)
  }
  return null;
}

function getStoredConfig() {
  try {
    const configPath = getConfigPath();
    if (existsSync(configPath)) {
      return JSON.parse(readFileSync(configPath, 'utf-8'));
    }
  } catch (error) {
    // Ignore errors
  }
  return null;
}

async function storeToken(token) {
  try {
    const configPath = getConfigPath();
    const configDir = join(homedir(), '.vibex');
    if (!existsSync(configDir)) {
      await mkdir(configDir, { recursive: true });
    }
    
    const config = {
      token,
      updatedAt: new Date().toISOString(),
    };
    
    await writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');
    return true;
  } catch (error) {
    console.error('Failed to store token:', error.message);
    return false;
  }
}

async function handleLogin() {
  const configPath = getConfigPath();
  const existingConfig = getStoredConfig();
  const { webUrl } = getProductionUrls();
  
  console.log('\n  üîê vibex.sh CLI Authentication\n');
  console.log(`  üìÅ Config location: ${configPath}`);
  
  if (existingConfig?.token) {
    console.log(`  ‚ö†Ô∏è  You already have a token stored. This will replace it.\n`);
  }
  
  // Generate unique state (nonce) for OAuth flow
  const state = crypto.randomBytes(16).toString('hex');
  const authUrl = `${webUrl}/api/cli-auth?state=${state}`;
  
  console.log('  Opening browser for authentication...\n');
  console.log(`  If browser doesn't open, visit: ${authUrl}\n`);
  
  // Open browser
  const platform = process.platform;
  let command;
  if (platform === 'darwin') {
    command = 'open';
  } else if (platform === 'win32') {
    command = 'start';
  } else {
    command = 'xdg-open';
  }
  
  spawn(command, [authUrl], { detached: true, stdio: 'ignore' });
  
  // Poll for token
  console.log('  Waiting for authentication...');
  let attempts = 0;
  
  while (attempts < MAX_POLL_ATTEMPTS) {
    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
    attempts++;
    
    try {
      const response = await httpRequest(`${webUrl}/api/cli-auth?state=${state}`, {
        method: 'GET',
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.token) {
          await storeToken(data.token);
          const configPath = getConfigPath();
          console.log('\n  ‚úÖ Authentication successful!');
          console.log(`  üìÅ Token saved to: ${configPath}`);
          console.log(`  üí° This token will be used automatically for future commands.\n`);
          return data.token;
        }
      }
    } catch (error) {
      // Continue polling
    }
  }
  
  console.log('\n  ‚è±Ô∏è  Authentication timeout. Please try again.\n');
  process.exit(1);
}

function httpRequest(url, options) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const isHttps = urlObj.protocol === 'https:';
    const httpModule = isHttps ? https : http;
    
    const req = httpModule.request(url, options, (res) => {
      let data = '';
      res.on('data', (chunk) => { data += chunk; });
      res.on('end', () => {
        try {
          const parsed = JSON.parse(data);
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve(parsed) });
        } catch (e) {
          resolve({ ok: res.statusCode >= 200 && res.statusCode < 300, status: res.statusCode, json: () => Promise.resolve({}) });
        }
      });
    });
    
    req.on('error', reject);
    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}

// claimSession function removed - session claiming is no longer supported
// All sessions must be created with authentication

// Removed getSessionAuthCode - auth codes should only come from:
// 1. claim-session-with-token response (for claimed sessions)
// 2. socket.io session-auth-code event (for unclaimed sessions)
// Never fetch auth codes via public API endpoint - security vulnerability 

function printBanner(sessionId, authCode = null) {
  const { webUrl } = getProductionUrls();
  const dashboardUrl = authCode 
    ? `${webUrl}/${sessionId}?auth=${authCode}`
    : `${webUrl}/${sessionId}`;
  
  console.log('\n');
  console.log('  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('  ‚ïë         üîç vibex.sh is watching...    ‚ïë');
  console.log('  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log('\n');
  console.log(`  Session ID: ${sessionId}`);
  if (authCode) {
    console.log(`  Auth Code:  ${authCode}`);
  }
  console.log(`  Dashboard:  ${dashboardUrl}`);
  console.log('\n');
}

/**
 * Handle init command - create a new session with parser selection
 */
async function handleInit(options) {
  const { webUrl } = getProductionUrls();
  
  // Interactive prompt for parser selection
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  
  const question = (query) => new Promise((resolve) => rl.question(query, resolve));
  
  try {
    console.log('\n  üîß vibex.sh Session Initialization\n');
    
    // Fetch available parsers from public API
    let availableParsers = [];
    try {
      const parsersResponse = await httpRequest(`${webUrl}/api/parsers`, {
        method: 'GET',
      });
      if (parsersResponse.ok) {
        availableParsers = await parsersResponse.json();
      } else {
        console.warn('  ‚ö†Ô∏è  Failed to fetch parsers from API, using fallback list');
      }
    } catch (e) {
      console.warn('  ‚ö†Ô∏è  Failed to fetch parsers from API, using fallback list');
    }
    
    // Fallback to hardcoded list if API fails or returns empty
    if (!availableParsers || availableParsers.length === 0) {
      availableParsers = [
        { id: 'nginx', name: 'Nginx Access Log', category: 'web' },
        { id: 'apache', name: 'Apache Access Log', category: 'web' },
        { id: 'docker', name: 'Docker Container Logs', category: 'system' },
        { id: 'kubernetes', name: 'Kubernetes Pod/Container Logs', category: 'system' },
      ];
    }
    
    // Filter out mandatory parsers for selection (if any)
    const selectableParsers = availableParsers.filter(p => !p.isMandatory);
    
    console.log('  What kind of logs are these? (Optional - leave empty for auto-detection)');
    if (selectableParsers.length > 0) {
      console.log('  Available log types:');
      selectableParsers.forEach((p, i) => {
        console.log(`    ${i + 1}. ${p.name} (${p.id})`);
      });
      console.log('    (Leave empty for auto-detection)\n');
    } else {
      console.log('  Available log types: (Leave empty for auto-detection)\n');
    }
    
    const answer = await question('  Enter comma-separated numbers or parser IDs (e.g., 1,2 or nginx,apache): ');
    rl.close();
    
    let enabledParsers = [];
    if (answer.trim()) {
      const selections = answer.split(',').map(s => s.trim());
      selections.forEach(sel => {
        // Check if it's a number
        const num = parseInt(sel, 10);
        if (!isNaN(num) && num > 0 && num <= selectableParsers.length) {
          enabledParsers.push(selectableParsers[num - 1].id);
        } else if (selectableParsers.find(p => p.id === sel)) {
          enabledParsers.push(sel);
        }
      });
    }
    
    // Use parser flag if provided, otherwise use interactive selection
    const parserFlag = options.parser || options.parsers;
    if (parserFlag) {
      if (typeof parserFlag === 'string') {
        enabledParsers = parserFlag.split(',').map(p => p.trim());
      }
    }
    
    // Get token - required for authenticated session creation
    let token = process.env.VIBEX_TOKEN || await getStoredToken();
    if (!token) {
      console.error('\n  ‚úó Authentication required');
      console.error('  üí° Run: npx vibex-sh login');
      process.exit(1);
    }
    
    // Create session with enabledParsers (authenticated)
    const createUrl = `${webUrl}/api/sessions/create`;
    const response = await httpRequest(createUrl, {
      method: 'POST',
      headers: { 
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({
        enabledParsers: enabledParsers.length > 0 ? enabledParsers : undefined,
      }),
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      if (response.status === 401 || response.status === 403) {
        console.error(`\n  ‚úó Authentication failed: ${errorData.message || 'Invalid token'}`);
        console.error('  üí° Run: npx vibex-sh login');
      } else {
        console.error(`\n  ‚úó Failed to create session: ${errorData.message || 'Unknown error'}`);
      }
      process.exit(1);
    }
    
    const data = await response.json();
    const createdSessionId = data.sessionId;
    const createdAuthCode = data.authCode;
    
      console.log('\n  ‚úÖ Session created successfully!\n');
      printBanner(createdSessionId, createdAuthCode);
    if (enabledParsers.length > 0) {
      console.log(`  üìã Log Types: ${enabledParsers.join(', ')}`);
    } else {
      console.log('  üìã Log Types: Auto-detection (default parsers)');
    }
    console.log(`\n  üí° Use this session ID: ${createdSessionId}`);
    console.log(`  Example: echo '{"cpu": 45}' | npx vibex-sh -s ${createdSessionId}\n`);
    
    process.exit(0);
  } catch (error) {
    rl.close();
    console.error(`\n  ‚úó Error: ${error.message}`);
    process.exit(1);
  }
}

async function main() {
  // Configure main program
  program
    .name('vibex')
    .description('vibex.sh CLI - Send logs to vibex.sh for real-time analysis')
    .version(cliVersion, '-v, --version', 'Display version number');

  // Login command
  program
    .command('login')
    .description('Authenticate with vibex.sh and save your token')
    .action(async () => {
      await handleLogin();
      process.exit(0);
    });

  // Init command
  program
    .command('init')
    .description('Create a new session with parser selection')
    .option('--parser <parsers>', 'Comma-separated list of parser IDs (e.g., nginx,postgres)')
    .option('--parsers <parsers>', 'Alias for --parser')
    .action(async (options) => {
      await handleInit(options);
    });

  // Main command (default) - send logs
  program
    .option('-s, --session-id <id>', 'Reuse existing session ID')
    .option('--token <token>', 'Authentication token (or use VIBEX_TOKEN env var)')
    .option('--parser <parsers>', 'Comma-separated list of parser IDs (e.g., nginx,postgres)')
    .option('--parsers <parsers>', 'Alias for --parser')
    .action(async (options) => {
      await handleSendLogs(options);
    });

  // Parse arguments
  program.parse();
}

/**
 * Handle send logs command (default/main command)
 */
async function handleSendLogs(options) {
  const { webUrl, socketUrl } = getProductionUrls();
  
  // Get token - REQUIRED for all operations
  let token = options.token || process.env.VIBEX_TOKEN || await getStoredToken();
  if (!token) {
    console.error('\n  ‚úó Authentication required');
    console.error('  üí° Run: npx vibex-sh login to authenticate');
    console.error('  üí° Or set VIBEX_TOKEN environment variable\n');
    process.exit(1);
  }
  
  let sessionId;
  let authCode = null;
  
  // Check if stdin is available (piped input)
  const isTTY = process.stdin.isTTY;
  const hasStdin = !isTTY;
  
  // If no session ID and no stdin, show usage and exit
  if (!options.sessionId && !hasStdin) {
    program.help();
    process.exit(0);
  }
  
  // If session ID is provided, use it (existing session)
  if (options.sessionId) {
    sessionId = normalizeSessionId(options.sessionId);
    
    // When reusing a session, show minimal info
    console.log(`  üîç Sending logs to session: ${sessionId}\n`);
  } else {
    // No session ID provided - create a new authenticated session
    // Check for --parser or --parsers flag for parser selection
    let enabledParsers = [];
    if (options.parser || options.parsers) {
      const parserList = options.parser || options.parsers;
      if (Array.isArray(parserList)) {
        enabledParsers = parserList;
      } else if (typeof parserList === 'string') {
        enabledParsers = parserList.split(',').map(p => p.trim());
      }
    }
    
    try {
      const createUrl = `${webUrl}/api/sessions/create`;
      const response = await httpRequest(createUrl, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({
          enabledParsers: enabledParsers.length > 0 ? enabledParsers : undefined,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        if (response.status === 401 || response.status === 403) {
          console.error(`  ‚úó Authentication failed: ${errorData.message || 'Invalid token'}`);
          console.error('  üí° Run: npx vibex-sh login');
        } else {
          console.error(`  ‚úó Failed to create session: ${errorData.message || 'Unknown error'}`);
        }
        process.exit(1);
      }
      
      const data = await response.json();
      sessionId = data.sessionId; // Server-generated unique session ID
      authCode = data.authCode; // Server-generated auth code
      
      // Print banner for new session
      printBanner(sessionId, authCode);
      if (enabledParsers.length > 0) {
        console.log(`  üìã Log Types: ${enabledParsers.join(', ')}`);
      } else {
        console.log('  üìã Log Types: Auto-detection (default parsers)');
      }
      console.log('  üí° Tip: Use -s to send more logs to this session');
      console.log(`  Example: echo '{"cpu": 45, "memory": 78}' | npx vibex-sh -s ${sessionId}\n`);
    } catch (error) {
      console.error(`  ‚úó Error creating session: ${error.message}`);
      process.exit(1);
    }
  }

  let socket = null;
  let isConnected = false;
  let hasJoinedSession = false;
  const logQueue = [];
  let reconnectTimeout = null;
  let reconnectAttempts = 0;
  const maxReconnectDelay = 5000;

  // Connection state management
  let connectionState = 'disconnected'; // disconnected, connecting, connected, closing, closed
  let connectionEstablished = false;
  let connectionLock = false;
  let connectionStartTime = null;

  // Store auth code received from socket
  let receivedAuthCode = authCode;
  
  // Track if this is a new session (not reusing an existing one)
  const isNewSession = !options.sessionId;

  // Graceful shutdown function
  const closeWebSocket = () => {
    return new Promise((resolve) => {
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        if (connectionState === 'connected' || connectionState === 'closing') {
          connectionState = 'closed';
        }
        resolve();
        return;
      }
      
      connectionState = 'closing';
      const closeStartTime = Date.now();
      console.log('  üîÑ Initiating graceful WebSocket close...');
      
      const closeTimeout = setTimeout(() => {
        const elapsed = Date.now() - closeStartTime;
        console.log(`  ‚ö†Ô∏è  Close handshake timeout after ${elapsed}ms, forcing exit`);
        connectionState = 'closed';
        resolve();
      }, 2000);
      
      // Store original onclose handler
      const originalOnClose = socket.onclose;
      
      socket.onclose = (event) => {
        clearTimeout(closeTimeout);
        const elapsed = Date.now() - closeStartTime;
        connectionState = 'closed';
        connectionEstablished = false;
        console.log(`  ‚úì WebSocket closed gracefully (code: ${event.code}, reason: ${event.reason || 'none'}, time: ${elapsed}ms)`);
        
        // Call original handler if it exists
        if (originalOnClose) {
          originalOnClose(event);
        }
        
        resolve();
      };
      
      socket.close(1000, 'Stream ended');
    });
  };

  const connectWebSocket = () => {
    // Prevent multiple simultaneous connections
    if (connectionLock) {
      console.log('  ‚ö†Ô∏è  Connection already in progress, skipping...');
      return;
    }
    
    if (connectionState === 'connected' || connectionState === 'connecting') {
      console.log(`  ‚ö†Ô∏è  Already ${connectionState}, skipping new connection...`);
      return;
    }
    
    // Clear any existing reconnect timeout to prevent duplicate connections
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    connectionLock = true;
    connectionState = 'connecting';
    connectionStartTime = Date.now();
    console.log('  üîÑ Connecting to WebSocket...');
    
    try {
      // Close existing socket if any (cleanup)
      if (socket && socket.readyState !== WebSocket.CLOSED) {
        try {
          socket.close();
        } catch (e) {
          // Ignore errors when closing
        }
      }
      
      socket = new WebSocket(`${socketUrl}?sessionId=${sessionId}`);

      socket.onopen = () => {
        const connectTime = Date.now() - connectionStartTime;
        connectionLock = false;
        connectionState = 'connected';
        isConnected = true;
        connectionEstablished = true;
        console.log(`  ‚úì Connected to server (${connectTime}ms)\n`);
        reconnectAttempts = 0;

        // Join session
        socket.send(JSON.stringify({
          type: 'join-session',
          sessionId,
        }));

        // Set hasJoinedSession immediately - HTTP POST doesn't need WebSocket
        hasJoinedSession = true;
        // Process any queued logs immediately
        while (logQueue.length > 0) {
          const logData = logQueue.shift();
          // Send logs via HTTP POST (non-blocking) instead of WebSocket
          // WebSocket is only for receiving logs
          sendLogViaHTTP(logData);
        }
      };

      socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          switch (message.type) {
            case 'join-session-ack':
              console.log('  ‚úì Joined session\n');
              break;

            case 'session-auth-code':
              if (message.data && message.data.sessionId === sessionId && message.data.authCode) {
                if (!receivedAuthCode || receivedAuthCode !== message.data.authCode) {
                  receivedAuthCode = message.data.authCode;
                  if (isNewSession) {
                    const { webUrl } = getProductionUrls();
                    console.log(`  üîë Auth Code: ${receivedAuthCode}`);
                    console.log(`  üìã Dashboard: ${webUrl}/${sessionId}?auth=${receivedAuthCode}\n`);
                  }
                }
              }
              break;

            case 'log':
              // Logs are received via WebSocket but sent via HTTP
              break;

            case 'error':
              const errorType = message.error || 'Error';
              const errorMsg = message.message || 'An unexpected error occurred';
              const statusCode = message.statusCode || 0;
              
              // Handle specific error types
              if (errorType === 'Rate Limit Exceeded' || statusCode === 429) {
                console.error('\n  ‚ö†Ô∏è  Rate Limit Exceeded');
                console.error(`  ${errorMsg}`);
                if (message.retryAfter) {
                  console.error(`  ‚è±Ô∏è  Retry after: ${message.retryAfter} seconds`);
                }
                console.error('');
                logQueue.length = 0;
              } else if (errorType === 'History Limit Reached' || (statusCode === 403 && errorMsg.includes('History Limit'))) {
                console.error('\n  üö´ History Limit Reached');
                console.error(`  ${errorMsg}`);
                if (message.limit !== undefined && message.current !== undefined) {
                  console.error(`  Current: ${message.current} / ${message.limit} logs`);
                }
                if (message.upgradeRequired) {
                  console.error('  üí° Upgrade to Pro to unlock 30 days retention');
                  console.error('  üåê Visit: https://vibex.sh/pricing');
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 401 || errorType === 'Unauthorized') {
                if (errorMsg.includes('expired')) {
                  console.error('\n  üîë Token Expired');
                  console.error('  Your authentication token has expired.');
                  console.error('  üí° Run: npx vibex-sh login');
                } else {
                  console.error('\n  üîë Unauthorized');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° Run: npx vibex-sh login');
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 403 || errorType === 'Forbidden') {
                if (errorMsg.includes('access') || errorMsg.includes('belongs')) {
                  console.error('\n  üö´ Access Denied');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° This session belongs to another user or is not accessible');
                  console.error('  üí° Make sure you are using the correct token and session ID');
                } else if (errorMsg.includes('archived')) {
                  console.error('\n  üö´ Session Archived');
                  console.error(`  ${errorMsg}`);
                  console.error('  üí° This session is archived and cannot accept new logs');
                } else {
                  console.error('\n  üö´ Forbidden');
                  console.error(`  ${errorMsg}`);
                }
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 404 || errorType === 'Not Found') {
                console.error('\n  üîç Session Not Found');
                console.error(`  ${errorMsg}`);
                console.error('  üí° Make sure the session ID is correct');
                console.error('  üí° Check if the session exists in your dashboard');
                console.error('');
                logQueue.length = 0;
                hasJoinedSession = false;
              } else if (statusCode === 400 || errorType === 'Bad Request') {
                console.error('\n  üìù Bad Request');
                console.error(`  ${errorMsg}`);
                if (errorMsg.includes('sessionId')) {
                  console.error('  üí° Make sure you provided a valid session ID with -s or --session');
                } else if (errorMsg.includes('logs')) {
                  console.error('  üí° Make sure you are sending valid log data');
                }
                console.error('');
                logQueue.length = 0;
              } else if (statusCode >= 500 || errorType === 'Internal Server Error') {
                console.error('\n  üî¥ Server Error');
                console.error(`  ${errorMsg}`);
                console.error('  üí° This is a server-side issue. Please try again later.');
                console.error('  üí° If the problem persists, contact support');
                console.error('');
                logQueue.length = 0;
              } else {
                console.error('\n  ‚úó Error');
                console.error(`  ${errorType}: ${errorMsg}`);
                if (statusCode) {
                  console.error(`  Status Code: ${statusCode}`);
                }
                console.error('');
                logQueue.length = 0;
              }
              break;

            default:
              // Ignore unknown message types
              break;
          }
        } catch (error) {
          console.error('  ‚úó Error parsing message:', error.message);
        }
      };

      socket.onerror = (error) => {
        if (!isConnected) {
          console.error(`  ‚úó Connection error: ${error.message || 'websocket error'}`);
          console.error(`  ‚Üª Trying to connect to: ${socketUrl}`);
          console.error('  ‚Üª Retrying connection...\n');
        }
      };

      socket.onclose = (event) => {
        connectionLock = false;
        connectionState = 'closed';
        connectionEstablished = false;
        isConnected = false;
        hasJoinedSession = false;
        
        const connectionDuration = connectionStartTime ? Date.now() - connectionStartTime : 0;
        console.log(`  üìä Connection closed (code: ${event.code}, reason: ${event.reason || 'none'}, duration: ${connectionDuration}ms)`);

        // Reconnect logic - only if not a normal closure and not already closing
        if (event.code !== 1000 && connectionState !== 'closing') {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), maxReconnectDelay);
          reconnectAttempts++;
          console.log(`  ‚Üª Reconnecting in ${delay}ms (attempt ${reconnectAttempts})...\n`);
          
          reconnectTimeout = setTimeout(() => {
            connectWebSocket();
          }, delay);
        } else if (event.code === 1000) {
          console.log('  ‚úì Normal closure, no reconnect needed\n');
        }
      };
    } catch (error) {
      connectionLock = false;
      connectionState = 'disconnected';
      connectionEstablished = false;
      console.error(`  ‚úó Error creating WebSocket: ${error.message}`);
      console.error(`  ‚Üª URL: ${socketUrl}`);
      // Retry connection
      reconnectTimeout = setTimeout(() => {
        connectWebSocket();
      }, 1000);
    }
  };

  // Send logs via HTTP POST (non-blocking, same as SDKs)
  // Always use production Cloudflare Worker endpoint
  // Token is REQUIRED - all sessions must be authenticated
  // HTTP POST works independently of WebSocket - don't wait for WebSocket connection
  const sendLogViaHTTP = async (logData) => {
    try {
      // Always use production worker URL
      const workerUrl = process.env.VIBEX_WORKER_URL || DEFAULT_WORKER_URL;
      const ingestUrl = `${workerUrl}/api/v1/ingest`;
            
      // Build headers - Authorization is REQUIRED
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      };
      
      const response = await fetch(ingestUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          sessionId,
          logs: [logData],
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.message || response.statusText || 'Unknown error';
        
        console.error(`\n  ‚úó HTTP ${response.status}: ${errorMessage}`);
        
        // Handle specific error cases
        if (response.status === 401) {
          if (errorMessage.includes('expired')) {
            console.error('\n  üîë Token Expired');
            console.error('  Your authentication token has expired.');
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          } else if (errorMessage.includes('Invalid') || errorMessage.includes('invalid')) {
            console.error('\n  üîë Invalid Token');
            console.error('  Your authentication token is invalid or missing.');
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          } else {
            console.error('\n  üîë Unauthorized');
            console.error(`  ${errorMessage}`);
            console.error('  üí° Run: npx vibex-sh login');
            console.error('');
          }
        } else if (response.status === 400) {
          console.error('\n  üìù Bad Request');
          console.error(`  ${errorMessage}`);
          if (errorMessage.includes('sessionId')) {
            console.error('  üí° Make sure you provided a valid session ID with -s or --session');
          } else if (errorMessage.includes('logs')) {
            console.error('  üí° Make sure you are sending valid log data');
          }
          console.error('');
        } else if (response.status === 403) {
          if (errorMessage.includes('History Limit')) {
            console.error('\n  üö´ History Limit Reached');
            console.error(`  ${errorMessage}`);
            if (errorData.upgradeRequired) {
              console.error('  üí° Upgrade to Pro to unlock 30 days retention');
              console.error('  üåê Visit: https://vibex.sh/pricing');
            }
            console.error('');
          } else if (errorMessage.includes('access') || errorMessage.includes('belongs')) {
            console.error('\n  üö´ Access Denied');
            console.error(`  ${errorMessage}`);
            console.error('  üí° This session belongs to another user or is not accessible');
            console.error('  üí° Make sure you are using the correct token and session ID');
            console.error('');
          } else if (errorMessage.includes('archived')) {
            console.error('\n  üö´ Session Archived');
            console.error(`  ${errorMessage}`);
            console.error('  üí° This session is archived and cannot accept new logs');
            console.error('');
          } else {
            console.error('\n  üö´ Forbidden');
            console.error(`  ${errorMessage}`);
            console.error('');
          }
        } else if (response.status === 404) {
          console.error('\n  üîç Session Not Found');
          console.error(`  ${errorMessage}`);
          console.error('  üí° Make sure the session ID is correct');
          console.error('  üí° Check if the session exists in your dashboard');
          console.error('');
        } else if (response.status === 429) {
          console.error('\n  ‚ö†Ô∏è  Rate Limit Exceeded');
          console.error(`  ${errorMessage}`);
          if (errorData.retryAfter) {
            console.error(`  ‚è±Ô∏è  Retry after: ${errorData.retryAfter} seconds`);
          }
          console.error('');
        } else if (response.status >= 500) {
          console.error('\n  üî¥ Server Error');
          console.error(`  ${errorMessage}`);
          console.error('  üí° This is a server-side issue. Please try again later.');
          console.error('  üí° If the problem persists, contact support');
          console.error('');
        } else {
          console.error(`  ${errorMessage}`);
          console.error('');
        }
      } else {
        const result = await response.json().catch(() => ({}));
        console.log(`  ‚úì Log sent successfully (processed: ${result.processed || 1})`);
      }
    } catch (error) {
      console.error(`  ‚úó Error sending log to ${ingestUrl}:`, error.message);
    }
  };

  // Only start WebSocket connection if we have stdin (piped input)
  // Don't connect WebSocket when run without parameters
  if (hasStdin) {
    connectWebSocket();
  }

  // Only read from stdin if we have piped input
  if (!hasStdin) {
    // No stdin - exit after showing session info
    process.exit(0);
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  });

  rl.on('line', (line) => {
    const trimmedLine = line.trim();
    if (!trimmedLine) {
      return;
    }

    let logData;
    try {
      const parsed = JSON.parse(trimmedLine);
      // Phase 1.8: Normalize JSON to hybrid structure
      if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
        const hybrid = normalizeToHybrid(null, null, parsed);
        logData = {
          type: 'json',
          payload: hybrid,
          timestamp: Date.now(),
        };
      } else {
        // Parsed but not an object - treat as text
        logData = {
          type: 'json',
          payload: {
            message: trimmedLine,
            level: 'debug',
            metrics: {},
            context: {},
          },
          timestamp: Date.now(),
        };
      }
    } catch (e) {
      // Phase 1.8: Text logs are now valuable - send as message field
      logData = {
        type: 'json',
        payload: {
          message: trimmedLine,
          level: 'debug',
          metrics: {},
          context: {},
        },
        timestamp: Date.now(),
      };
    }

    // Send logs via HTTP POST immediately - don't wait for WebSocket
    // WebSocket is only for receiving logs and auth codes, not required for sending
    sendLogViaHTTP(logData);
  });

  rl.on('close', async () => {
    // Wait for queued logs to be sent
    const waitForQueue = () => {
      return new Promise((resolve) => {
        if (logQueue.length === 0) {
          resolve();
        } else {
          setTimeout(() => waitForQueue().then(resolve), 100);
        }
      });
    };
    
    await waitForQueue();
    
    console.log('\n  Stream ended. Closing connection...\n');
    
    // Cancel any pending reconnection attempts
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    // Graceful shutdown - wait for close handshake (only if WebSocket was connected)
    if (hasStdin && socket) {
      await closeWebSocket();
    }
    
    // Give a moment for any final cleanup
    setTimeout(() => process.exit(0), 100);
  });

  process.on('SIGINT', async () => {
    console.log('\n  Interrupted. Closing connection...\n');
    
    // Cancel any pending reconnection attempts
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    // Graceful shutdown
    await closeWebSocket();
    
    process.exit(0);
  });
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});

